<!DOCTYPE html>
<html>
  <head>
    <title>Trivia Quiz Project</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="css/normalize.css" />
    <link rel="stylesheet" href="css/styles.css" />
  </head>
  <body></body>
  <script>
    // using the global namespace for these for simplicity
    // get a service to hold state of this quiz session
    let quizService;
    // get a factory that can dynamically create questions based on type
    let questionFactory;

    window.onload = function() {
      // instantiate our service and factory
      quizService = new QuizService();
      questionFactory = new QuestionFactory();

      createAppStructure(); // create skeleton of page
      createStartButton(); // creating start button which has an event to kick things off
    };

    // This array is used to store the question data in an array for now
    // multiple-choice schema is: questionType,question,answer,choice-1,choice-2,...,choice-n
    // true-false schema is: questionTYpe,question,answer - true/false added on creation of question
    const questionPool = [
      [
        "multiple-choice",
        "What is your favorite color?",
        "Red",
        "Green",
        "Blue",
        "Red"
      ],
      [
        "multiple-choice",
        "What is your favorite food?",
        "Pizza",
        "Chicken Strips",
        "Pizza",
        "Vegetables"
      ],
      ["true-false", "Winter is coming.", "True"]
    ];

    // helper function to make element creation less verbose elsewhere
    function createElement(tagName, attributes) {
      let el = document.createElement(tagName);
      // overwrite any element defaults attributes argument values and return the element
      return Object.assign(el, attributes);
    }

    // helper function to clear a div
    function clearChildren(element) {
      while (element.lastChild) {
        element.removeChild(element.lastChild);
      }
    }

    /*
      This class uses a factory pattern to return a question
      object based on the type of question asked for.
      Only multiple choice and true/false are supported but
      adding text-based questions will be trivial now.
    */
    class QuestionFactory {
      // return question object based on question type
      create(questionConfig) {
        switch (questionConfig.questionType) {
          case "multiple-choice":
          case "true-false":
            // true-false is just a special case of multiple choice
            // they both can use the same type of object
            return new MultipleChoice(questionConfig);
          default:
            break;
        }
      }
    }

    /*
      This class uses a repository pattern to store questions
      in an array for a quiz session.  Encapsulating this makes
      it easier to switch over to using a database later.
    */
    class QuizService {
      constructor() {
        // array to hold questions for this quiz session
        this._questions = [];
        this._results = [];
      }

      addQuestion(question) {
        // the questions array is in memory now, but this could
        // easily call into an api
        return this._questions.push(question);
      }

      // return all questions for this session as a getter property
      get questions() {
        return this._questions;
      }

      // return the number of questions
      get questionCount() {
        return this._questions.length;
      }

      get stats() {
        // this function maps the historical results for the session
        // and returns them along with an overall score for each attempt
        const attempts = this._results.map((result, index) => {
          // each result here represents one attempt at the quiz
          const correct = result.questionCount - result.errors.length;
          const missed = result.errors.length;
          const score = Math.round((correct / result.questionCount) * 100);
          return {
            attempt: result.attempt,
            correct: correct,
            missed: missed,
            totalQuestions: result.questionCount,
            score: score
          };
        });

        // this reduction just aggregates the sum of attempt scores to use in
        // the overall score calculation
        const scoreSum = attempts.reduce((acc, curr) => acc + curr.score, 0);
        const overallScore = Math.round(scoreSum / attempts.length);

        // returns an array with stats for each attempt as well as overall
        // score across all attempts
        return { attempts, overallScore };
      }

      // empties out questions array
      clearQuestions() {
        this._questions = [];
      }

      addResult(result) {
        // determine how many attempts have been made
        const attemptNumber = this._results.length + 1;
        // add the attempt number to the result
        result = Object.assign(result, { attempt: attemptNumber });
        // prepend the result to the front of the results array
        // this is done so that we can see most recent attempt first
        this._results.unshift(result);
      }

      validateQuestions() {
        const errors = [];
        // call each question in the current quiz's validate method
        // and push any errors to the array to be returned
        this._questions.forEach((question, index) => {
          if (!question.validate()) {
            errors.push(index);
          }
        });

        // return array containing the indices of missed questions
        // this isn't used yet, but could be used to highlight wrong
        // answers
        return errors;
      }
    }

    /*
      This class defines a multiple choice question and is able
      to produce the correct DOM node. It will later have a function
      to verify the selected answer against the questionConfig's
      correct answer property.
    */
    class MultipleChoice {
      constructor(questionConfig) {
        this.questionType = questionConfig.questionType;
        this.question = questionConfig.question;
        this.correctAnswer = questionConfig.correctAnswer;
        this.choices = questionConfig.choices;
        this.groupName = "";

        // if no choices were specified, we must be dealing
        // with a true false question so we will add those
        // two choices here. 
        if (this.choices.length === 0) {
          this.choices = this.choices.concat(["True", "False"]);
        }
      }

      // function to create dom node with question and radio buttons
      render(index) {
        index = index || 0;
        // create a unique id for the wrapper and radio group to use
        const id = `${this.questionType}-${index}`;

        // create a div for the wrapper, question, and choices
        const wrapperDiv = createElement("div", {
          id: id,
          className: "question"
        });
        const questionDiv = createElement("div", {
          className: "question-text",
          innerText: this.question
        });
        const choicesDiv = createElement("div", { className: "choices" });

        // create a groupname for the radio buttons
        this.groupName = `${id}-choice`;

        wrapperDiv.appendChild(questionDiv);
        wrapperDiv.appendChild(choicesDiv);

        this.choices.forEach((choice, index) => {
          // create radio input and label for each choice in question config
          const radioId = `${this.groupName}-${index}`;
          const input = createElement("input", {
            type: "radio",
            name: this.groupName,
            value: choice,
            id: radioId,
            defaultChecked: false,
            checked: false
          });
          const label = createElement("label", { htmlFor: radioId });
          label.appendChild(document.createTextNode(choice));

          const choiceDiv = createElement("div", { className: "choice" });
          choiceDiv.appendChild(input);
          choiceDiv.appendChild(label);
          choicesDiv.appendChild(choiceDiv);
        });

        return wrapperDiv;
      }

      // function to validate given answer against correct answer from config
      validate() {
        // radio options should always be grouped, this is just a guard
        if (this.groupName === "") return false;

        // getElementsByName doesn't return an actual array, the slice call
        // here converts array-like things into a real array
        const radioItems = [].slice.call(
          document.getElementsByName(this.groupName)
        );

        // get the user's selected radio item
        const selectedAnswer = radioItems.find(item => item.checked);

        // not selecting an item counts as a missed question
        if (!selectedAnswer) return false;

        // compare the value of the radio item to the correct answer
        return (
          selectedAnswer.value.toLowerCase() ===
          this.correctAnswer.toLowerCase()
        );
      }
    }

    function renderQuestions() {
      // clear questions from last quiz attempt
      quizService.clearQuestions();

      questionPool.forEach(item => {
        // destructure the array item from the pool
        let [questionType, question, correctAnswer, ...choices] = item;

        // create a "questionConfig" object to send to factory
        const questionConfig = {
          questionType: questionType,
          question: question,
          correctAnswer: correctAnswer,
          choices: choices
        };

        // add factory-created question to this quiz session
        quizService.addQuestion(questionFactory.create(questionConfig));
      });

      quizService.questions.forEach((question, index) => {
        // loop through each question and call its render method
        // index is passed in to ensure unique element ids and names
        const questionNode = question.render(index);
        // append the question to the app div
        document.getElementById("questions").appendChild(questionNode);
      });
    }

    function checkAnswers() {
      // get the number of errors and question count for this attempt
      const errors = quizService.validateQuestions();
      const questionCount = quizService.questionCount;
      return { errors, questionCount };
    }

    function createAppStructure() {
      // this function just builds the page layout
      // the sections and divs here will be used to hold quiz elements
      const main = createElement("main");
      const homeSection = createElement("section", { id: "home-section" });
      const quizSection = createElement("section", { id: "quiz-section" });
      const statsDiv = createElement("div", { id: "stats" });
      const startDiv = createElement("div", { id: "start" });
      const questionsDiv = createElement("div", { id: "questions" });
      const finishDiv = createElement("div", { id: "finish" });
      homeSection.appendChild(statsDiv);
      homeSection.appendChild(startDiv);
      quizSection.appendChild(questionsDiv);
      quizSection.appendChild(finishDiv);
      main.appendChild(homeSection);
      main.appendChild(quizSection);
      document.body.appendChild(main);
    }

    function renderStats() {
      const statsDiv = document.getElementById("stats");

      // get the calculated stats from the quiz service
      const stats = quizService.stats;

      // if there were no attempts, we have nothing to do here
      if (stats.attempts.length === 0) {
        return false;
      }

      // create a wrapper for the stats and append the overall score
      const listWrapper = createElement("div", { id: "stats-wrapper" });
      const overallScore = createElement("div", {
        innerText: `Overall Score: ${stats.overallScore}%`
      });

      listWrapper.appendChild(overallScore);

      // create a ul element to list our previous attempt scores
      const list = createElement("ul", { id: "stats-list" });

      stats.attempts.forEach(attempt => {
        // each attempt gets a li element with its individual score
        const item = createElement("li", {
          innerText: `Attempt ${attempt.attempt}: ${attempt.score}%`
        });
        list.appendChild(item);
      });

      listWrapper.appendChild(list);
      statsDiv.appendChild(listWrapper);
    }

    function createStartButton() {
      // this is the start button to begin a quiz attempt
      const startDiv = document.getElementById("start");
      const startButton = createElement("button", {
        id: "startButton",
        innerText: "Start Quiz"
      });

      startButton.addEventListener("click", event => {
        // clicking the start button hides the home section
        // and displays a quiz
        setDisplayMode("quiz");

        // render each question from the pool on page load
        renderQuestions(quizService, questionFactory);

        // the finish button will be used to check the quiz
        // answers and return to the home "mode" that shows 
        // the start button and stats
        createFinishButton(quizService);

        // the quit button will return to the home "mode"
        // and does not count as an attempt
        createQuitButton();
      });

      startDiv.appendChild(startButton);
    }

    function setDisplayMode(mode) {
      // this function switches between "home mode" and "quiz mode"
      // the reason for this is so we don't have to create multiple
      // pages.  it is a pseudo-spa app
      const homeSection = document.getElementById("home-section");
      const quizSection = document.getElementById("quiz-section");
      const questionsDiv = document.getElementById("questions");
      const finishDiv = document.getElementById("finish");
      const statsDiv = document.getElementById("stats");
      switch (mode) {
        case "home":
          // in home mode we want to display the start button and stats
          // and hide the quiz elements
          homeSection.classList.remove("hidden");
          quizSection.classList.add("hidden");
          clearChildren(questionsDiv);
          clearChildren(finishDiv);
          clearChildren(statsDiv);
          break;
        case "quiz":
          // in quiz mode we want to display quiz elements like
          // questions and the check answer button
          homeSection.classList.add("hidden");
          quizSection.classList.remove("hidden");
          break;
          // we won't get down here, but if we do...nothing happens
        default:
          break;
      }
    }

    function restart(results) {
      // sets the display back the home "mode" and shows the stats
      setDisplayMode("home");
      renderStats();
    }

    function createFinishButton() {
      // this button is used to score the quiz
      const finish = document.getElementById("finish");

      const finishButton = createElement("button", {
        id: "checkAnswers",
        innerText: "Check Answers"
      });

      finishButton.addEventListener("click", () => {
        // when the button is clicked, the checkAnswers function
        // will use the quiz service to retrieve the results
        const result = checkAnswers();
        // if we want to do anything with the results before returning
        // to the home mode, we could do that here.  we don't for now.
        quizService.addResult(result);

        // reset the display to the home mode with the start button and stats
        restart();
      });

      finish.appendChild(finishButton);
    }

    function createQuitButton() {
      // button to click to abort a quiz attempt
      const finish = document.getElementById("finish");
      const quitButton = createElement("button", {
        id: "quitButton",
        innerText: "Quit"
      });

      // clicking the button resets the screen
      quitButton.addEventListener("click", restart);
      finish.appendChild(quitButton);
    }
  </script>
</html>
