<!DOCTYPE html>
<html>
  <head>
    <title>Trivia Quiz Project</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="css/normalize.css" />
    <link rel="stylesheet" href="css/styles.css" />
  </head>
  <body></body>
  <script>
    // declare a service to hold state of this quiz session
    let quizService;
    // declare a factory that can dynamically create questions based on type
    let questionFactory;

    window.onload = function() {
      // instantiate our service and factory after the window loads
      quizService = new QuizService();
      questionFactory = new QuestionFactory();

      createAppStructure(); // create skeleton of page
      createStartButton(); // creating start button which has an event to kick things off
    };

    // JSON formatted question pool that can serialized elsewhere if needed
    const questionPool = {
      "questions": [
        {
          "questionType": "multiple-choice",
          "question": "What is your favorite color?",
          "correctAnswers": ["Red"],
          "choices": ["Green", "Blue", "Red"]
        },
        {
          "questionType": "multiple-choice",
          "question": "What is your favorite food?",
          "correctAnswers": ["Pizza"],
          "choices": ["Chicken Strips", "Pizza", "Vegetables"]
        },
        {
          "questionType": "true-false",
          "question": "Winter is coming.",
          "correctAnswers": ["true"],
          "choices": ["True", "False"]
        },
        {
          "questionType": "text-based",
          "question": "Is it 2020 yet?",
          "correctAnswers": ["yes", "sure", "of course", "yup"]
        }
      ]
    };

    // helper function to make element creation less verbose
    function createElement(tagName, attributes) {
      let el = document.createElement(tagName);
      // overwrite any element defaults attributes argument values and return the element
      return Object.assign(el, attributes);
    }

    // helper function to clear a div
    function clearChildren(element) {
      while (element.lastChild) {
        // keep removing last child element as long as one exists
        element.removeChild(element.lastChild);
      }
    }

    /*
      This class uses a factory pattern to return a question
      object based on the type of question asked for.
      Muliple-choice, true-false, and text-based supported.
    */
    class QuestionFactory {
      // return question object based on question type
      create(questionConfig) {
        switch (questionConfig.questionType) {
          case "multiple-choice":
          case "true-false":
            // true-false is just a special case of multiple choice
            // they both can be represented by the same type of object
            return new MultipleChoice(questionConfig);
            break;
          case "text-based":
            return new TextBased(questionConfig);
            break;
          default:
            break;
        }
      }
    }

    /*
      This class uses a repository pattern to store questions
      in an array for a quiz session.  Encapsulating this makes
      it easier to switch over to using a database later.
    */
    class QuizService {
      constructor() {
        // array to hold questions for this quiz session
        this._questions = [];
        this._results = [];
      }

      addQuestion(question) {
        // the questions array is in memory now, but this could
        // easily call into an api
        return this._questions.push(question);
      }

      // return all questions for this session as a getter property
      get questions() {
        return this._questions;
      }

      // return the number of questions
      get questionCount() {
        return this._questions.length;
      }

      get stats() {
        // this function maps the historical results for the session
        // and returns them along with an overall score for all attempts
        const attempts = this._results.map((result, index) => {
          // each result here represents one attempt at the quiz
          const correct = result.questionCount - result.errors.length;
          const missed = result.errors.length;
          const score = Math.round((correct / result.questionCount) * 100);
          return {
            attempt: result.attempt,
            correct: correct,
            missed: missed,
            totalQuestions: result.questionCount,
            score: score
          };
        });

        // this reduction just aggregates the sum of attempt scores to use in
        // the overall score calculation
        const scoreSum = attempts.reduce((acc, curr) => acc + curr.score, 0);
        const overallScore = Math.round(scoreSum / attempts.length);

        // returns an array with stats for each attempt as well as overall
        // score across all attempts
        return { attempts, overallScore };
      }

      // empties out questions array
      clearQuestions() {
        this._questions = [];
      }

      addResult(result) {
        // determine how many attempts have been made
        const attemptCount = this._results.length + 1;
        // add the attempt count to the result
        result = Object.assign(result, { attempt: attemptCount });
        // prepend the result to the front of the results array
        // this is done so that we can see most recent attempt first
        this._results.unshift(result);
      }

      validateQuestions() {
        const errors = [];
        // call each question in the current quiz's validate method
        // and push any errors to the array to be returned
        this._questions.forEach((question, index) => {
          if (!question.validate()) {
            errors.push(index);
          }
        });

        // return array containing the indices of missed questions
        // this isn't used yet, but could be used to highlight wrong
        // answers
        return errors;
      }
    }

    /*
      This class defines a multiple choice question and is able
      to produce the correct DOM node and validate user input.
    */
    class MultipleChoice {
      constructor(questionConfig) {
        // assign properties of question config to this object
        Object.assign(this, questionConfig);
        // id will be the type of question and the question index
        this.id = "";
        // group name to use when naming our elements
        this.groupName = "";
      }

      // function to create dom node with question and radio buttons
      render(index) {
        // create a unique id for the wrapper and radio group to use
        this.id = `${this.questionType}-${index}`;
        // create a groupname for the radio buttons
        this.groupName = `${this.id}-choice`;

        // create a div for the wrapper, question, and choices
        const wrapperDiv = createElement("div", {
          id: this.id,
          className: "question"
        });
        // div with the question text inside
        const questionDiv = createElement("div", {
          className: "question-text",
          innerText: this.question
        });
        // div to hold all the radio inputs
        const choicesDiv = createElement("div", { className: "choices" });

        wrapperDiv.appendChild(questionDiv);
        wrapperDiv.appendChild(choicesDiv);

        this.choices.forEach((choice, index) => {
          // create radio input and label for each choice in question config
          const radioId = `${this.groupName}-${index}`;
          const input = createElement("input", {
            type: "radio",
            name: this.groupName,
            value: choice,
            id: radioId,
            defaultChecked: false,
            checked: false
          });
          const label = createElement("label", { htmlFor: radioId });
          label.appendChild(document.createTextNode(choice));

          // create div for radio input and append to choices
          const choiceDiv = createElement("div", { className: "choice" });
          choiceDiv.appendChild(input);
          choiceDiv.appendChild(label);
          choicesDiv.appendChild(choiceDiv);
        });

        // return the entire question node
        return wrapperDiv;
      }

      // function to validate given answer against correct answer from config
      validate() {
        // radio options should always be grouped, this is just a guard
        if (this.groupName === "") return false;

        // getElementsByName doesn't return an actual array, the slice call
        // here converts array-like things into a real array
        const radioItems = [].slice.call(
          document.getElementsByName(this.groupName)
        );

        // get the user's selected radio item
        const selectedAnswer = radioItems.find(item => item.checked);

        // not selecting an item counts as a missed question
        if (!selectedAnswer) return false;

        // compare the value of the radio item to the correct answer
        return (
          selectedAnswer.value.toLowerCase() ===
          this.correctAnswers[0].toLowerCase()
        );
      }
    }

    /*
      This class defines a text-based question and is able
      to produce the correct DOM node and validate user input.
    */
    class TextBased {
      constructor(questionConfig) {
        // assign properties of question config to this object
        Object.assign(this, questionConfig);
        this.id = ""; // id for question itself
        this.inputId = ""; // id for input box
      }

      // function to create dom node with question and radio buttons
      render(index) {
        // id will be the type of question and the question index
        this.id = `${this.questionType}-${index}`;
        // input id will have question id with -text appended
        this.inputId = `${this.id}-text`;

        // create a wrapper div to hold the question and input box
        const wrapperDiv = createElement("div", {
          id: this.id,
          className: "question"
        });

        // div with the question text inside
        const questionDiv = createElement("div", {
          className: "question-text",
          innerText: this.question
        });

        // create a div to hold the answer input element
        const inputDiv = createElement("div", { className: "userText" });
        const inputElement = createElement("input", {
          type: "text",
          id: this.inputId
        });
        inputDiv.appendChild(inputElement);

        // place input element in question div
        wrapperDiv.appendChild(questionDiv);
        wrapperDiv.appendChild(inputDiv);

        // return the entire question node
        return wrapperDiv;
      }

      // function to validate given answer against correct answer from config
      validate() {
        const inputElement = document.getElementById(this.inputId);
        const userAnswer = inputElement.value.trim();
        // make regex to match against any accepted answer
        const regex = new RegExp(this.correctAnswers.join("|"));

        // return result of regex test against user input
        return regex.test(userAnswer);
      }
    }

    function renderQuestions() {
      // clear questions from last quiz attempt
      quizService.clearQuestions();
      
      // iterate questions from the questionPool JSON
      questionPool.questions.forEach(item => {
        // pass item to factory to create correct question type object
        const question = questionFactory.create(item);
        // add our factory-created question to the quiz service
        quizService.addQuestion(question);
      });

      quizService.questions.forEach((question, index) => {
        // loop through each question and call its render method.
        // index is passed in to ensure unique element ids and names
        const questionNode = question.render(index);
        // append the question to the app div
        document.getElementById("questions").appendChild(questionNode);
      });
    }

    function checkAnswers() {
      // get the number of errors and a question count for this attempt
      const errors = quizService.validateQuestions();
      const questionCount = quizService.questionCount;
      return { errors, questionCount };
    }

    function createAppStructure() {
      // this function just builds the page layout
      // the sections and divs here will be used to hold quiz elements
      const main = createElement("main");
      const homeSection = createElement("section", { id: "home-section" });
      const quizSection = createElement("section", { id: "quiz-section" });
      const statsDiv = createElement("div", { id: "stats" });
      const startDiv = createElement("div", { id: "start" });
      const questionsDiv = createElement("div", { id: "questions" });
      const finishDiv = createElement("div", { id: "finish" });
      homeSection.appendChild(statsDiv);
      homeSection.appendChild(startDiv);
      quizSection.appendChild(questionsDiv);
      quizSection.appendChild(finishDiv);
      main.appendChild(homeSection);
      main.appendChild(quizSection);
      document.body.appendChild(main);
    }

    function renderStats() {
      // get referenct to the stats div
      const statsDiv = document.getElementById("stats");

      // get the calculated stats from the quiz service
      const stats = quizService.stats;

      // if there were no attempts, we have nothing to do here
      if (stats.attempts.length === 0) {
        return false;
      }

      // create a wrapper for the stats and append the overall score
      const listWrapper = createElement("div", { id: "stats-wrapper" });
      const overallScore = createElement("div", {
        innerText: `Overall Score: ${stats.overallScore}%`
      });

      listWrapper.appendChild(overallScore);

      // create a ul element to list our previous attempt scores
      const list = createElement("ul", { id: "stats-list" });

      stats.attempts.forEach(attempt => {
        // each attempt gets a li element with its individual score
        const item = createElement("li", {
          innerText: `Attempt ${attempt.attempt}: ${attempt.score}%`
        });
        list.appendChild(item);
      });

      listWrapper.appendChild(list);
      statsDiv.appendChild(listWrapper);
    }

    function createStartButton() {
      // this is the start button to begin a quiz attempt
      const startDiv = document.getElementById("start");
      const startButton = createElement("button", {
        id: "startButton",
        innerText: "Start Quiz"
      });

      startButton.addEventListener("click", event => {
        // clicking the start button hides the home section
        // and displays a quiz
        setDisplayMode("quiz");

        // render each question from the pool on page load
        renderQuestions(quizService, questionFactory);

        // the finish button will be used to check the quiz
        // answers and return to the home "mode" that shows
        // the start button and stats
        createFinishButton(quizService);

        // the quit button will return to the home "mode"
        // and does not count as an attempt
        createQuitButton();
      });

      startDiv.appendChild(startButton);
    }

    function setDisplayMode(mode) {
      // this function switches between "home mode" and "quiz mode"
      // the reason for this is so we don't have to create multiple
      // pages.  this will be a single page application
      const homeSection = document.getElementById("home-section");
      const quizSection = document.getElementById("quiz-section");
      const questionsDiv = document.getElementById("questions");
      const finishDiv = document.getElementById("finish");
      const statsDiv = document.getElementById("stats");
      switch (mode) {
        case "home":
          // in home mode we want to display the start button and stats
          // and hide the quiz elements
          homeSection.classList.remove("hidden");
          quizSection.classList.add("hidden");
          clearChildren(questionsDiv);
          clearChildren(finishDiv);
          clearChildren(statsDiv);
          break;
        case "quiz":
          // in quiz mode we only want to display quiz elements like
          // questions and the check answer button
          homeSection.classList.add("hidden");
          quizSection.classList.remove("hidden");
          break;
          // we won't get down here, but if we do...nothing happens
        default:
          break;
      }
    }

    function restart(results) {
      // sets the display back the home "mode" and shows the stats
      setDisplayMode("home");
      renderStats();
    }

    function createFinishButton() {
      // reference to div that will hold the finish button
      const finish = document.getElementById("finish");
      
      // this button is used to score the quiz
      const finishButton = createElement("button", {
        id: "checkAnswers",
        innerText: "Check Answers"
      });

      finishButton.addEventListener("click", () => {
        // when the button is clicked, the checkAnswers function
        // will use the quiz service to retrieve the results
        const result = checkAnswers();
        // if we want to do anything with the results before returning
        // to the home mode, we could do that here.  we don't for now.
        quizService.addResult(result);

        // reset the display to the home mode with the start button and stats
        restart();
      });

      finish.appendChild(finishButton);
    }

    function createQuitButton() {
      // button to click to abort a quiz attempt
      const finish = document.getElementById("finish");
      const quitButton = createElement("button", {
        id: "quitButton",
        innerText: "Quit"
      });

      // clicking the button resets the screen
      quitButton.addEventListener("click", restart);
      finish.appendChild(quitButton);
    }
  </script>
</html>
